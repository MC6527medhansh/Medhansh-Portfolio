"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-utils";
exports.ids = ["vendor-chunks/troika-three-utils"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BezierMesh: () => (/* binding */ BezierMesh),\n/* harmony export */   createDerivedMaterial: () => (/* binding */ createDerivedMaterial),\n/* harmony export */   expandShaderIncludes: () => (/* binding */ expandShaderIncludes),\n/* harmony export */   getShaderUniformTypes: () => (/* binding */ getShaderUniformTypes),\n/* harmony export */   getShadersForMaterial: () => (/* binding */ getShadersForMaterial),\n/* harmony export */   invertMatrix4: () => (/* binding */ invertMatrix4),\n/* harmony export */   voidMainRegExp: () => (/* binding */ voidMainRegExp)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\n/**\n * Regular expression for matching the `void main() {` opener line in GLSL.\n * @type {RegExp}\n */ const voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n/**\n * Recursively expands all `#include <xyz>` statements within string of shader code.\n * Copied from three's WebGLProgram#parseIncludes for external use.\n *\n * @param {string} source - The GLSL source code to evaluate\n * @return {string} The GLSL code with all includes expanded\n */ function expandShaderIncludes(source) {\n    const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n    function replace(match, include) {\n        let chunk = three__WEBPACK_IMPORTED_MODULE_0__.ShaderChunk[include];\n        return chunk ? expandShaderIncludes(chunk) : match;\n    }\n    return source.replace(pattern, replace);\n}\n/*\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n */ const _lut = [];\nfor(let i = 0; i < 256; i++){\n    _lut[i] = (i < 16 ? \"0\" : \"\") + i.toString(16);\n}\nfunction generateUUID() {\n    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n    const d0 = Math.random() * 0xffffffff | 0;\n    const d1 = Math.random() * 0xffffffff | 0;\n    const d2 = Math.random() * 0xffffffff | 0;\n    const d3 = Math.random() * 0xffffffff | 0;\n    const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + \"-\" + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + \"-\" + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + \"-\" + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + \"-\" + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n    // .toUpperCase() here flattens concatenated strings to save heap memory space.\n    return uuid.toUpperCase();\n}\n// Local assign polyfill to avoid importing troika-core\nconst assign = Object.assign || function() {\n    let target = arguments[0];\n    for(let i = 1, len = arguments.length; i < len; i++){\n        let source = arguments[i];\n        if (source) {\n            for(let prop in source){\n                if (Object.prototype.hasOwnProperty.call(source, prop)) {\n                    target[prop] = source[prop];\n                }\n            }\n        }\n    }\n    return target;\n};\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map();\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nlet materialInstanceId = 1e10;\n/**\n * A utility for creating a custom shader material derived from another material's\n * shaders. This allows you to inject custom shader logic and transforms into the\n * builtin ThreeJS materials without having to recreate them from scratch.\n *\n * @param {THREE.Material} baseMaterial - the original material to derive from\n *\n * @param {Object} options - How the base material should be modified.\n * @param {Object=} options.defines - Custom `defines` for the material\n * @param {Object=} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n * @param {Object=} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n * @param {String=} options.timeUniform - If specified, a uniform of this name will be injected into\n *        both shaders, and it will automatically be updated on each render frame with a number of\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n *        true calendar time.\n * @param {String=} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String=} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n *        shader's `void main` function.\n * @param {String=} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n *        shader's `void main` function.\n * @param {String=} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n *        those attributes exposed by their normal names as read/write values.\n * @param {String=} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String=} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n *        shader's `void main` function.\n * @param {String=} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n *        want those to apply to your changes use `fragmentColorTransform` instead.\n * @param {String=} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n *        output value. Will be injected near the end of the `void main` function, but before any\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n *        `fragmentMainOutro`.\n * @param {function({fragmentShader: string, vertexShader:string}):\n *        {fragmentShader: string, vertexShader:string}} options.customRewriter - A function\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\n *        special that's not covered by the other builtin options. This function will be executed before\n *        any other transforms are applied.\n * @param {boolean=} options.chained - Set to `true` to prototype-chain the derived material to the base\n *        material, rather than the default behavior of copying it. This allows the derived material to\n *        automatically pick up changes made to the base material and its properties. This can be useful\n *        where the derived material is hidden from the user as an implementation detail, allowing them\n *        to work with the original material like normal. But it can result in unexpected behavior if not\n *        handled carefully.\n *\n * @return {THREE.Material}\n *\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n * which can be called to get a variant of the derived material for use in shadow casting. If the\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\n */ function createDerivedMaterial(baseMaterial, options) {\n    // Generate a key that is unique to the content of these `options`. We'll use this\n    // throughout for caching and for generating the upgraded shader code. This increases\n    // the likelihood that the resulting shaders will line up across multiple calls so\n    // their GL programs can be shared and cached.\n    const optionsKey = getKeyForOptions(options);\n    // First check to see if we've already derived from this baseMaterial using this\n    // unique set of options, and if so reuse the constructor to avoid some allocations.\n    let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n    if (!ctorsByDerivation) {\n        CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = Object.create(null));\n    }\n    if (ctorsByDerivation[optionsKey]) {\n        return new ctorsByDerivation[optionsKey]();\n    }\n    const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n    // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n    // the renderer switches to this material's program\n    const onBeforeCompile = function(shaderInfo, renderer) {\n        baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n        // Upgrade the shaders, caching the result by incoming source code\n        const cacheKey = this.customProgramCacheKey() + \"|\" + shaderInfo.vertexShader + \"|\" + shaderInfo.fragmentShader;\n        let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n        if (!upgradedShaders) {\n            const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n            upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n        }\n        // Inject upgraded shaders and uniforms into the program\n        shaderInfo.vertexShader = upgradedShaders.vertexShader;\n        shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n        assign(shaderInfo.uniforms, this.uniforms);\n        // Inject auto-updating time uniform if requested\n        if (options.timeUniform) {\n            shaderInfo.uniforms[options.timeUniform] = {\n                get value () {\n                    return Date.now() - epoch;\n                }\n            };\n        }\n        // Users can still add their own handlers on top of ours\n        if (this[privateBeforeCompileProp]) {\n            this[privateBeforeCompileProp](shaderInfo);\n        }\n    };\n    const DerivedMaterial = function DerivedMaterial() {\n        return derive(options.chained ? baseMaterial : baseMaterial.clone());\n    };\n    const derive = function(base) {\n        // Prototype chain to the base material\n        const derived = Object.create(base, descriptor);\n        // Store the baseMaterial for reference; this is always the original even when cloning\n        Object.defineProperty(derived, \"baseMaterial\", {\n            value: baseMaterial\n        });\n        // Needs its own ids\n        Object.defineProperty(derived, \"id\", {\n            value: materialInstanceId++\n        });\n        derived.uuid = generateUUID();\n        // Merge uniforms, defines, and extensions\n        derived.uniforms = assign({}, base.uniforms, options.uniforms);\n        derived.defines = assign({}, base.defines, options.defines);\n        derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = \"\"; //force a program change from the base material\n        derived.extensions = assign({}, base.extensions, options.extensions);\n        // Don't inherit EventDispatcher listeners\n        derived._listeners = undefined;\n        return derived;\n    };\n    const descriptor = {\n        constructor: {\n            value: DerivedMaterial\n        },\n        isDerivedMaterial: {\n            value: true\n        },\n        type: {\n            get: ()=>baseMaterial.type,\n            set: (value)=>{\n                baseMaterial.type = value;\n            }\n        },\n        isDerivedFrom: {\n            writable: true,\n            configurable: true,\n            value: function(testMaterial) {\n                const base = this.baseMaterial;\n                return testMaterial === base || base.isDerivedMaterial && base.isDerivedFrom(testMaterial) || false;\n            }\n        },\n        customProgramCacheKey: {\n            writable: true,\n            configurable: true,\n            value: function() {\n                return baseMaterial.customProgramCacheKey() + \"|\" + optionsKey;\n            }\n        },\n        onBeforeCompile: {\n            get () {\n                return onBeforeCompile;\n            },\n            set (fn) {\n                this[privateBeforeCompileProp] = fn;\n            }\n        },\n        copy: {\n            writable: true,\n            configurable: true,\n            value: function(source) {\n                baseMaterial.copy.call(this, source);\n                if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n                    assign(this.extensions, source.extensions);\n                    assign(this.defines, source.defines);\n                    assign(this.uniforms, three__WEBPACK_IMPORTED_MODULE_1__.UniformsUtils.clone(source.uniforms));\n                }\n                return this;\n            }\n        },\n        clone: {\n            writable: true,\n            configurable: true,\n            value: function() {\n                const newBase = new baseMaterial.constructor();\n                return derive(newBase).copy(this);\n            }\n        },\n        /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */ getDepthMaterial: {\n            writable: true,\n            configurable: true,\n            value: function() {\n                let depthMaterial = this._depthMaterial;\n                if (!depthMaterial) {\n                    depthMaterial = this._depthMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new three__WEBPACK_IMPORTED_MODULE_1__.MeshDepthMaterial({\n                        depthPacking: three__WEBPACK_IMPORTED_MODULE_1__.RGBADepthPacking\n                    }), options);\n                    depthMaterial.defines.IS_DEPTH_MATERIAL = \"\";\n                    depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n                }\n                return depthMaterial;\n            }\n        },\n        /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */ getDistanceMaterial: {\n            writable: true,\n            configurable: true,\n            value: function() {\n                let distanceMaterial = this._distanceMaterial;\n                if (!distanceMaterial) {\n                    distanceMaterial = this._distanceMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new three__WEBPACK_IMPORTED_MODULE_1__.MeshDistanceMaterial(), options);\n                    distanceMaterial.defines.IS_DISTANCE_MATERIAL = \"\";\n                    distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n                }\n                return distanceMaterial;\n            }\n        },\n        dispose: {\n            writable: true,\n            configurable: true,\n            value () {\n                const { _depthMaterial, _distanceMaterial } = this;\n                if (_depthMaterial) _depthMaterial.dispose();\n                if (_distanceMaterial) _distanceMaterial.dispose();\n                baseMaterial.dispose.call(this);\n            }\n        }\n    };\n    ctorsByDerivation[optionsKey] = DerivedMaterial;\n    return new DerivedMaterial();\n}\nfunction upgradeShaders(material, { vertexShader, fragmentShader }, options, key) {\n    let { vertexDefs, vertexMainIntro, vertexMainOutro, vertexTransform, fragmentDefs, fragmentMainIntro, fragmentMainOutro, fragmentColorTransform, customRewriter, timeUniform } = options;\n    vertexDefs = vertexDefs || \"\";\n    vertexMainIntro = vertexMainIntro || \"\";\n    vertexMainOutro = vertexMainOutro || \"\";\n    fragmentDefs = fragmentDefs || \"\";\n    fragmentMainIntro = fragmentMainIntro || \"\";\n    fragmentMainOutro = fragmentMainOutro || \"\";\n    // Expand includes if needed\n    if (vertexTransform || customRewriter) {\n        vertexShader = expandShaderIncludes(vertexShader);\n    }\n    if (fragmentColorTransform || customRewriter) {\n        // We need to be able to find postprocessing chunks after include expansion in order to\n        // put them after the fragmentColorTransform, so mark them with comments first. Even if\n        // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n        // so we still mark them.\n        fragmentShader = fragmentShader.replace(/^[ \\t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm, \"\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n\");\n        fragmentShader = expandShaderIncludes(fragmentShader);\n    }\n    // Apply custom rewriter function\n    if (customRewriter) {\n        let res = customRewriter({\n            vertexShader,\n            fragmentShader\n        });\n        vertexShader = res.vertexShader;\n        fragmentShader = res.fragmentShader;\n    }\n    // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n    // those and re-insert them into the outro in the correct place:\n    if (fragmentColorTransform) {\n        let postChunks = [];\n        fragmentShader = fragmentShader.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, (match)=>{\n            postChunks.push(match);\n            return \"\";\n        });\n        fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join(\"\\n\")}\\n${fragmentMainOutro}`;\n    }\n    // Inject auto-updating time uniform if requested\n    if (timeUniform) {\n        const code = `\\nuniform float ${timeUniform};\\n`;\n        vertexDefs = code + vertexDefs;\n        fragmentDefs = code + fragmentDefs;\n    }\n    // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n    if (vertexTransform) {\n        // Hoist these defs to the very top so they work in other function defs\n        vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n        vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n        vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n        vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr)=>{\n            return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;\n        });\n        // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n        // Perhaps the other textures too going forward?\n        if (!(material.map && material.map.channel > 0)) {\n            vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n        }\n    }\n    // Inject defs and intro/outro snippets\n    vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n    fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n    return {\n        vertexShader,\n        fragmentShader\n    };\n}\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n    if (intro || outro || defs) {\n        shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`);\n        shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n    }\n    return shaderCode;\n}\nfunction optionsJsonReplacer(key, value) {\n    return key === \"uniforms\" ? undefined : typeof value === \"function\" ? value.toString() : value;\n}\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n    const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n    let id = optionsHashesToIds.get(optionsHash);\n    if (id == null) {\n        optionsHashesToIds.set(optionsHash, id = ++_idCtr);\n    }\n    return id;\n}\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nconst MATERIAL_TYPES_TO_SHADERS = {\n    MeshDepthMaterial: \"depth\",\n    MeshDistanceMaterial: \"distanceRGBA\",\n    MeshNormalMaterial: \"normal\",\n    MeshBasicMaterial: \"basic\",\n    MeshLambertMaterial: \"lambert\",\n    MeshPhongMaterial: \"phong\",\n    MeshToonMaterial: \"toon\",\n    MeshStandardMaterial: \"physical\",\n    MeshPhysicalMaterial: \"physical\",\n    MeshMatcapMaterial: \"matcap\",\n    LineBasicMaterial: \"basic\",\n    LineDashedMaterial: \"dashed\",\n    PointsMaterial: \"points\",\n    ShadowMaterial: \"shadow\",\n    SpriteMaterial: \"sprite\"\n};\n/**\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n * used to render that material.\n *\n * @param material - the Material instance\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n */ function getShadersForMaterial(material) {\n    let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n    return builtinType ? three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n    ;\n}\n/**\n * Find all uniforms and their types within a shader code string.\n *\n * @param {string} shader - The shader code to parse\n * @return {object} mapping of uniform names to their glsl type\n */ function getShaderUniformTypes(shader) {\n    let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n    let uniforms = Object.create(null);\n    let match;\n    while((match = uniformRE.exec(shader)) !== null){\n        uniforms[match[2]] = match[1];\n    }\n    return uniforms;\n}\n/**\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n * that happened in ThreeJS r123.\n * @param {Matrix4} srcMatrix\n * @param {Matrix4} [tgtMatrix]\n */ function invertMatrix4(srcMatrix, tgtMatrix = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4()) {\n    if (typeof tgtMatrix.invert === \"function\") {\n        tgtMatrix.copy(srcMatrix).invert();\n    } else {\n        tgtMatrix.getInverse(srcMatrix);\n    }\n    return tgtMatrix;\n}\n/*\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\ndivided into a reasonable number of height segments.\n*/ const vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\nfunction createBezierMeshMaterial(baseMaterial) {\n    return createDerivedMaterial(baseMaterial, {\n        chained: true,\n        uniforms: {\n            pointA: {\n                value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()\n            },\n            controlA: {\n                value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()\n            },\n            controlB: {\n                value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()\n            },\n            pointB: {\n                value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()\n            },\n            radius: {\n                value: 0.01\n            },\n            dashing: {\n                value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()\n            } //on, off, offset\n        },\n        vertexDefs,\n        vertexTransform,\n        fragmentDefs,\n        fragmentMainIntro\n    });\n}\nlet geometry = null;\nconst defaultBaseMaterial = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({\n    color: 0xffffff,\n    side: three__WEBPACK_IMPORTED_MODULE_1__.DoubleSide\n});\n/**\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n * automatically.\n *\n * The cubiz bezier path is determined by its four `Vector3` properties:\n * - `pointA`\n * - `controlA`\n * - `controlB`\n * - `pointB`\n *\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n *\n * You can also give the tube a dashed appearance with two properties:\n *\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n *   used as input to the cubic bezier function, not its visible length.)\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n *\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n * thicker tubes.\n *\n * TODO: proper geometry bounding sphere and raycasting\n * TODO: allow control of the geometry's segment counts\n */ class BezierMesh extends three__WEBPACK_IMPORTED_MODULE_1__.Mesh {\n    static getGeometry() {\n        return geometry || (geometry = new three__WEBPACK_IMPORTED_MODULE_1__.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));\n    }\n    constructor(){\n        super(BezierMesh.getGeometry(), defaultBaseMaterial);\n        this.pointA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        this.controlA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        this.controlB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        this.pointB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        this.radius = 0.01;\n        this.dashArray = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2();\n        this.dashOffset = 0;\n        // TODO - disabling frustum culling until I figure out how to customize the\n        //  geometry's bounding sphere that gets used\n        this.frustumCulled = false;\n    }\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    get material() {\n        let derivedMaterial = this._derivedMaterial;\n        const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n        if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n            derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n            // dispose the derived material when its base material is disposed:\n            baseMaterial.addEventListener(\"dispose\", function onDispose() {\n                baseMaterial.removeEventListener(\"dispose\", onDispose);\n                derivedMaterial.dispose();\n            });\n        }\n        return derivedMaterial;\n    }\n    set material(baseMaterial) {\n        this._baseMaterial = baseMaterial;\n    }\n    // Create and update material for shadows upon request:\n    get customDepthMaterial() {\n        return this.material.getDepthMaterial();\n    }\n    get customDistanceMaterial() {\n        return this.material.getDistanceMaterial();\n    }\n    onBeforeRender() {\n        const { uniforms } = this.material;\n        const { pointA, controlA, controlB, pointB, radius, dashArray, dashOffset } = this;\n        uniforms.pointA.value.copy(pointA);\n        uniforms.controlA.value.copy(controlA);\n        uniforms.controlB.value.copy(controlB);\n        uniforms.pointB.value.copy(pointB);\n        uniforms.radius.value = radius;\n        uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    }\n    raycast() {\n    // TODO - just fail for now\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBOE07QUFFOU07OztDQUdDLEdBQ0QsTUFBTWEsaUJBQWlCO0FBRXZCOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLHFCQUFzQkMsTUFBTTtJQUNuQyxNQUFNQyxVQUFVO0lBQ2hCLFNBQVNDLFFBQVFDLEtBQUssRUFBRUMsT0FBTztRQUM3QixJQUFJQyxRQUFRcEIsOENBQVcsQ0FBQ21CLFFBQVE7UUFDaEMsT0FBT0MsUUFBUU4scUJBQXFCTSxTQUFTRjtJQUMvQztJQUNBLE9BQU9ILE9BQU9FLE9BQU8sQ0FBRUQsU0FBU0M7QUFDbEM7QUFFQTs7OztDQUlDLEdBRUQsTUFBTUksT0FBTyxFQUFFO0FBRWYsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksS0FBS0EsSUFBSztJQUM1QkQsSUFBSSxDQUFDQyxFQUFFLEdBQUcsQ0FBQ0EsSUFBSSxLQUFLLE1BQU0sRUFBQyxJQUFLLEVBQUlDLFFBQVEsQ0FBQztBQUMvQztBQUVBLFNBQVNDO0lBRVAsc0dBQXNHO0lBRXRHLE1BQU1DLEtBQUtDLEtBQUtDLE1BQU0sS0FBSyxhQUFhO0lBQ3hDLE1BQU1DLEtBQUtGLEtBQUtDLE1BQU0sS0FBSyxhQUFhO0lBQ3hDLE1BQU1FLEtBQUtILEtBQUtDLE1BQU0sS0FBSyxhQUFhO0lBQ3hDLE1BQU1HLEtBQUtKLEtBQUtDLE1BQU0sS0FBSyxhQUFhO0lBQ3hDLE1BQU1JLE9BQU9WLElBQUksQ0FBQ0ksS0FBSyxLQUFLLEdBQUdKLElBQUksQ0FBQ0ksTUFBTSxJQUFJLEtBQUssR0FBR0osSUFBSSxDQUFDSSxNQUFNLEtBQUssS0FBSyxHQUFHSixJQUFJLENBQUNJLE1BQU0sS0FBSyxLQUFLLEdBQUcsTUFDcEdKLElBQUksQ0FBQ08sS0FBSyxLQUFLLEdBQUdQLElBQUksQ0FBQ08sTUFBTSxJQUFJLEtBQUssR0FB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LENBQUMsRUFBRWIsY0FBYztJQUNyRTtJQUVBYyxVQUFtQztJQUNqQywyQkFBMkI7SUFDN0I7QUFDRjtBQUVnSiIsInNvdXJjZXMiOlsid2VicGFjazovL21lZGhhbnNoLXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy90cm9pa2EtdGhyZWUtdXRpbHMvZGlzdC90cm9pa2EtdGhyZWUtdXRpbHMuZXNtLmpzPzU3NWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2hhZGVyQ2h1bmssIFVuaWZvcm1zVXRpbHMsIE1lc2hEZXB0aE1hdGVyaWFsLCBSR0JBRGVwdGhQYWNraW5nLCBNZXNoRGlzdGFuY2VNYXRlcmlhbCwgU2hhZGVyTGliLCBNYXRyaXg0LCBWZWN0b3IzLCBNZXNoLCBDeWxpbmRlckdlb21ldHJ5LCBWZWN0b3IyLCBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgRG91YmxlU2lkZSB9IGZyb20gJ3RocmVlJztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIHRoZSBgdm9pZCBtYWluKCkge2Agb3BlbmVyIGxpbmUgaW4gR0xTTC5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IHZvaWRNYWluUmVnRXhwID0gL1xcYnZvaWRcXHMrbWFpblxccypcXChcXHMqXFwpXFxzKnsvZztcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBleHBhbmRzIGFsbCBgI2luY2x1ZGUgPHh5ej5gIHN0YXRlbWVudHMgd2l0aGluIHN0cmluZyBvZiBzaGFkZXIgY29kZS5cbiAqIENvcGllZCBmcm9tIHRocmVlJ3MgV2ViR0xQcm9ncmFtI3BhcnNlSW5jbHVkZXMgZm9yIGV4dGVybmFsIHVzZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIC0gVGhlIEdMU0wgc291cmNlIGNvZGUgdG8gZXZhbHVhdGVcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdMU0wgY29kZSB3aXRoIGFsbCBpbmNsdWRlcyBleHBhbmRlZFxuICovXG5mdW5jdGlvbiBleHBhbmRTaGFkZXJJbmNsdWRlcyggc291cmNlICkge1xuICBjb25zdCBwYXR0ZXJuID0gL15bIFxcdF0qI2luY2x1ZGUgKzwoW1xcd1xcZC4vXSspPi9nbTtcbiAgZnVuY3Rpb24gcmVwbGFjZShtYXRjaCwgaW5jbHVkZSkge1xuICAgIGxldCBjaHVuayA9IFNoYWRlckNodW5rW2luY2x1ZGVdO1xuICAgIHJldHVybiBjaHVuayA/IGV4cGFuZFNoYWRlckluY2x1ZGVzKGNodW5rKSA6IG1hdGNoXG4gIH1cbiAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKCBwYXR0ZXJuLCByZXBsYWNlIClcbn1cblxuLypcbiAqIFRoaXMgaXMgYSBkaXJlY3QgY29weSBvZiBNYXRoVXRpbHMuZ2VuZXJhdGVVVUlEIGZyb20gVGhyZWUuanMsIHRvIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgd2l0aCB0aHJlZVxuICogdmVyc2lvbnMgYmVmb3JlIDAuMTEzLjAgYXMgaXQgd2FzIGNoYW5nZWQgZnJvbSBNYXRoIHRvIE1hdGhVdGlscyBpbiB0aGF0IHZlcnNpb24uXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2Jsb2IvZGQ4YjVhYTNiMjcwYzE3MDk2YjkwOTQ1Y2QyZDZkMWIxM2FhZWM1My9zcmMvbWF0aC9NYXRoVXRpbHMuanMjTDE2XG4gKi9cblxuY29uc3QgX2x1dCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIF9sdXRbaV0gPSAoaSA8IDE2ID8gJzAnIDogJycpICsgKGkpLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuXG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxuXG4gIGNvbnN0IGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgY29uc3QgZDIgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIGNvbnN0IGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCB1dWlkID0gX2x1dFtkMCAmIDB4ZmZdICsgX2x1dFtkMCA+PiA4ICYgMHhmZl0gKyBfbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QwID4+IDI0ICYgMHhmZl0gKyAnLScgK1xuICAgIF9sdXRbZDEgJiAweGZmXSArIF9sdXRbZDEgPj4gOCAmIDB4ZmZdICsgJy0nICsgX2x1dFtkMSA+PiAxNiAmIDB4MGYgfCAweDQwXSArIF9sdXRbZDEgPj4gMjQgJiAweGZmXSArICctJyArXG4gICAgX2x1dFtkMiAmIDB4M2YgfCAweDgwXSArIF9sdXRbZDIgPj4gOCAmIDB4ZmZdICsgJy0nICsgX2x1dFtkMiA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMiA+PiAyNCAmIDB4ZmZdICtcbiAgICBfbHV0W2QzICYgMHhmZl0gKyBfbHV0W2QzID4+IDggJiAweGZmXSArIF9sdXRbZDMgPj4gMTYgJiAweGZmXSArIF9sdXRbZDMgPj4gMjQgJiAweGZmXTtcblxuICAvLyAudG9VcHBlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG4gIHJldHVybiB1dWlkLnRvVXBwZXJDYXNlKClcblxufVxuXG4vLyBMb2NhbCBhc3NpZ24gcG9seWZpbGwgdG8gYXZvaWQgaW1wb3J0aW5nIHRyb2lrYS1jb3JlXG5jb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKC8qdGFyZ2V0LCAuLi5zb3VyY2VzKi8pIHtcbiAgbGV0IHRhcmdldCA9IGFyZ3VtZW50c1swXTtcbiAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXRcbn07XG5cblxuY29uc3QgZXBvY2ggPSBEYXRlLm5vdygpO1xuY29uc3QgQ09OU1RSVUNUT1JfQ0FDSEUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgU0hBREVSX1VQR1JBREVfQ0FDSEUgPSBuZXcgTWFwKCk7XG5cbi8vIE1hdGVyaWFsIGlkcyBtdXN0IGJlIGludGVnZXJzLCBidXQgd2UgY2FuJ3QgYWNjZXNzIHRoZSBpbmNyZW1lbnQgZnJvbSBUaHJlZSdzIGBNYXRlcmlhbGAgbW9kdWxlLFxuLy8gc28gbGV0J3MgY2hvb3NlIGEgc3VmZmljaWVudGx5IGxhcmdlIHN0YXJ0aW5nIHZhbHVlIHRoYXQgc2hvdWxkIHRoZW9yZXRpY2FsbHkgbmV2ZXIgY29sbGlkZS5cbmxldCBtYXRlcmlhbEluc3RhbmNlSWQgPSAxZTEwO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBmb3IgY3JlYXRpbmcgYSBjdXN0b20gc2hhZGVyIG1hdGVyaWFsIGRlcml2ZWQgZnJvbSBhbm90aGVyIG1hdGVyaWFsJ3NcbiAqIHNoYWRlcnMuIFRoaXMgYWxsb3dzIHlvdSB0byBpbmplY3QgY3VzdG9tIHNoYWRlciBsb2dpYyBhbmQgdHJhbnNmb3JtcyBpbnRvIHRoZVxuICogYnVpbHRpbiBUaHJlZUpTIG1hdGVyaWFscyB3aXRob3V0IGhhdmluZyB0byByZWNyZWF0ZSB0aGVtIGZyb20gc2NyYXRjaC5cbiAqXG4gKiBAcGFyYW0ge1RIUkVFLk1hdGVyaWFsfSBiYXNlTWF0ZXJpYWwgLSB0aGUgb3JpZ2luYWwgbWF0ZXJpYWwgdG8gZGVyaXZlIGZyb21cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEhvdyB0aGUgYmFzZSBtYXRlcmlhbCBzaG91bGQgYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMuZGVmaW5lcyAtIEN1c3RvbSBgZGVmaW5lc2AgZm9yIHRoZSBtYXRlcmlhbFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLmV4dGVuc2lvbnMgLSBDdXN0b20gYGV4dGVuc2lvbnNgIGZvciB0aGUgbWF0ZXJpYWwsIGUuZy4gYHtkZXJpdmF0aXZlczogdHJ1ZX1gXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMudW5pZm9ybXMgLSBDdXN0b20gYHVuaWZvcm1zYCBmb3IgdXNlIGluIHRoZSBtb2RpZmllZCBzaGFkZXIuIFRoZXNlIGNhblxuICogICAgICAgIGJlIGFjY2Vzc2VkIGFuZCBtYW5pcHVsYXRlZCB2aWEgdGhlIHJlc3VsdGluZyBtYXRlcmlhbCdzIGB1bmlmb3Jtc2AgcHJvcGVydHksIGp1c3QgbGlrZVxuICogICAgICAgIGluIGEgU2hhZGVyTWF0ZXJpYWwuIFlvdSBkbyBub3QgbmVlZCB0byByZXBlYXQgdGhlIGJhc2UgbWF0ZXJpYWwncyBvd24gdW5pZm9ybXMgaGVyZS5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy50aW1lVW5pZm9ybSAtIElmIHNwZWNpZmllZCwgYSB1bmlmb3JtIG9mIHRoaXMgbmFtZSB3aWxsIGJlIGluamVjdGVkIGludG9cbiAqICAgICAgICBib3RoIHNoYWRlcnMsIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgdXBkYXRlZCBvbiBlYWNoIHJlbmRlciBmcmFtZSB3aXRoIGEgbnVtYmVyIG9mXG4gKiAgICAgICAgZWxhcHNlZCBtaWxsaXNlY29uZHMuIFRoZSBcInplcm9cIiBlcG9jaCB0aW1lIGlzIG5vdCBzaWduaWZpY2FudCBzbyBkb24ndCByZWx5IG9uIHRoaXMgYXMgYVxuICogICAgICAgIHRydWUgY2FsZW5kYXIgdGltZS5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy52ZXJ0ZXhEZWZzIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgaW50byB0aGUgdmVydGV4IHNoYWRlcidzIHRvcC1sZXZlbFxuICogICAgICAgIGRlZmluaXRpb25zLCBhYm92ZSB0aGUgYHZvaWQgbWFpbigpYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy52ZXJ0ZXhNYWluSW50cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgdG9wIG9mIHRoZSB2ZXJ0ZXhcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy52ZXJ0ZXhNYWluT3V0cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgZW5kIG9mIHRoZSB2ZXJ0ZXhcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy52ZXJ0ZXhUcmFuc2Zvcm0gLSBDdXN0b20gR0xTTCBjb2RlIHRvIG1hbmlwdWxhdGUgdGhlIGBwb3NpdGlvbmAsIGBub3JtYWxgLFxuICogICAgICAgIGFuZC9vciBgdXZgIHZlcnRleCBhdHRyaWJ1dGVzLiBUaGlzIGNvZGUgd2lsbCBiZSB3cmFwcGVkIHdpdGhpbiBhIHN0YW5kYWxvbmUgZnVuY3Rpb24gd2l0aFxuICogICAgICAgIHRob3NlIGF0dHJpYnV0ZXMgZXhwb3NlZCBieSB0aGVpciBub3JtYWwgbmFtZXMgYXMgcmVhZC93cml0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge1N0cmluZz19IG9wdGlvbnMuZnJhZ21lbnREZWZzIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgaW50byB0aGUgZnJhZ21lbnQgc2hhZGVyJ3MgdG9wLWxldmVsXG4gKiAgICAgICAgZGVmaW5pdGlvbnMsIGFib3ZlIHRoZSBgdm9pZCBtYWluKClgIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLmZyYWdtZW50TWFpbkludHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIHRvcCBvZiB0aGUgZnJhZ21lbnRcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy5mcmFnbWVudE1haW5PdXRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50XG4gKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uIFlvdSBjYW4gbWFuaXB1bGF0ZSBgZ2xfRnJhZ0NvbG9yYCBoZXJlIGJ1dCBrZWVwIGluIG1pbmQgaXQgZ29lc1xuICogICAgICAgIGFmdGVyIGFueSBvZiBUaHJlZUpTJ3MgY29sb3IgcG9zdHByb2Nlc3Npbmcgc2hhZGVyIGNodW5rcyAodG9uZW1hcHBpbmcsIGZvZywgZXRjLiksIHNvIGlmIHlvdVxuICogICAgICAgIHdhbnQgdGhvc2UgdG8gYXBwbHkgdG8geW91ciBjaGFuZ2VzIHVzZSBgZnJhZ21lbnRDb2xvclRyYW5zZm9ybWAgaW5zdGVhZC5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy5mcmFnbWVudENvbG9yVHJhbnNmb3JtIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBtYW5pcHVsYXRlIHRoZSBgZ2xfRnJhZ0NvbG9yYFxuICogICAgICAgIG91dHB1dCB2YWx1ZS4gV2lsbCBiZSBpbmplY3RlZCBuZWFyIHRoZSBlbmQgb2YgdGhlIGB2b2lkIG1haW5gIGZ1bmN0aW9uLCBidXQgYmVmb3JlIGFueVxuICogICAgICAgIG9mIFRocmVlSlMncyBjb2xvciBwb3N0cHJvY2Vzc2luZyBzaGFkZXIgY2h1bmtzICh0b25lbWFwcGluZywgZm9nLCBldGMuKSwgYW5kIGJlZm9yZSB0aGVcbiAqICAgICAgICBgZnJhZ21lbnRNYWluT3V0cm9gLlxuICogQHBhcmFtIHtmdW5jdGlvbih7ZnJhZ21lbnRTaGFkZXI6IHN0cmluZywgdmVydGV4U2hhZGVyOnN0cmluZ30pOlxuICogICAgICAgIHtmcmFnbWVudFNoYWRlcjogc3RyaW5nLCB2ZXJ0ZXhTaGFkZXI6c3RyaW5nfX0gb3B0aW9ucy5jdXN0b21SZXdyaXRlciAtIEEgZnVuY3Rpb25cbiAqICAgICAgICBmb3IgcGVyZm9ybWluZyBjdXN0b20gcmV3cml0ZXMgb2YgdGhlIGZ1bGwgc2hhZGVyIGNvZGUuIFVzZWZ1bCBpZiB5b3UgbmVlZCB0byBkbyBzb21ldGhpbmdcbiAqICAgICAgICBzcGVjaWFsIHRoYXQncyBub3QgY292ZXJlZCBieSB0aGUgb3RoZXIgYnVpbHRpbiBvcHRpb25zLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlXG4gKiAgICAgICAgYW55IG90aGVyIHRyYW5zZm9ybXMgYXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRpb25zLmNoYWluZWQgLSBTZXQgdG8gYHRydWVgIHRvIHByb3RvdHlwZS1jaGFpbiB0aGUgZGVyaXZlZCBtYXRlcmlhbCB0byB0aGUgYmFzZVxuICogICAgICAgIG1hdGVyaWFsLCByYXRoZXIgdGhhbiB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBjb3B5aW5nIGl0LiBUaGlzIGFsbG93cyB0aGUgZGVyaXZlZCBtYXRlcmlhbCB0b1xuICogICAgICAgIGF1dG9tYXRpY2FsbHkgcGljayB1cCBjaGFuZ2VzIG1hZGUgdG8gdGhlIGJhc2UgbWF0ZXJpYWwgYW5kIGl0cyBwcm9wZXJ0aWVzLiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAqICAgICAgICB3aGVyZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBpcyBoaWRkZW4gZnJvbSB0aGUgdXNlciBhcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGFsbG93aW5nIHRoZW1cbiAqICAgICAgICB0byB3b3JrIHdpdGggdGhlIG9yaWdpbmFsIG1hdGVyaWFsIGxpa2Ugbm9ybWFsLiBCdXQgaXQgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW9yIGlmIG5vdFxuICogICAgICAgIGhhbmRsZWQgY2FyZWZ1bGx5LlxuICpcbiAqIEByZXR1cm4ge1RIUkVFLk1hdGVyaWFsfVxuICpcbiAqIFRoZSByZXR1cm5lZCBtYXRlcmlhbCB3aWxsIGFsc28gaGF2ZSB0d28gbmV3IG1ldGhvZHMsIGBnZXREZXB0aE1hdGVyaWFsKClgIGFuZCBgZ2V0RGlzdGFuY2VNYXRlcmlhbCgpYCxcbiAqIHdoaWNoIGNhbiBiZSBjYWxsZWQgdG8gZ2V0IGEgdmFyaWFudCBvZiB0aGUgZGVyaXZlZCBtYXRlcmlhbCBmb3IgdXNlIGluIHNoYWRvdyBjYXN0aW5nLiBJZiB0aGVcbiAqIHRhcmdldCBtZXNoIGlzIGV4cGVjdGVkIHRvIGNhc3Qgc2hhZG93cywgdGhlbiB5b3UgY2FuIGFzc2lnbiB0aGVzZSB0byB0aGUgbWVzaCdzIGBjdXN0b21EZXB0aE1hdGVyaWFsYFxuICogKGZvciBkaXJlY3Rpb25hbCBhbmQgc3BvdCBsaWdodHMpIGFuZC9vciBgY3VzdG9tRGlzdGFuY2VNYXRlcmlhbGAgKGZvciBwb2ludCBsaWdodHMpIHByb3BlcnRpZXMgdG9cbiAqIGFsbG93IHRoZSBjYXN0IHNoYWRvdyB0byBob25vciB5b3VyIGRlcml2ZWQgc2hhZGVyJ3MgdmVydGV4IHRyYW5zZm9ybXMgYW5kIGRpc2NhcmRlZCBmcmFnbWVudHMuIFRoZXNlXG4gKiB3aWxsIGFsc28gc2V0IGEgY3VzdG9tIGAjZGVmaW5lIElTX0RFUFRIX01BVEVSSUFMYCBvciBgI2RlZmluZSBJU19ESVNUQU5DRV9NQVRFUklBTGAgdGhhdCB5b3UgY2FuIGxvb2tcbiAqIGZvciBpbiB5b3VyIGRlcml2ZWQgc2hhZGVycyB3aXRoIGAjaWZkZWZgIHRvIGN1c3RvbWl6ZSB0aGVpciBiZWhhdmlvciBmb3IgdGhlIGRlcHRoIG9yIGRpc3RhbmNlXG4gKiBzY2VuYXJpb3MsIGUuZy4gc2tpcHBpbmcgYW50aWFsaWFzaW5nIG9yIGV4cGVuc2l2ZSBzaGFkZXIgbG9naWMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwsIG9wdGlvbnMpIHtcbiAgLy8gR2VuZXJhdGUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIGNvbnRlbnQgb2YgdGhlc2UgYG9wdGlvbnNgLiBXZSdsbCB1c2UgdGhpc1xuICAvLyB0aHJvdWdob3V0IGZvciBjYWNoaW5nIGFuZCBmb3IgZ2VuZXJhdGluZyB0aGUgdXBncmFkZWQgc2hhZGVyIGNvZGUuIFRoaXMgaW5jcmVhc2VzXG4gIC8vIHRoZSBsaWtlbGlob29kIHRoYXQgdGhlIHJlc3VsdGluZyBzaGFkZXJzIHdpbGwgbGluZSB1cCBhY3Jvc3MgbXVsdGlwbGUgY2FsbHMgc29cbiAgLy8gdGhlaXIgR0wgcHJvZ3JhbXMgY2FuIGJlIHNoYXJlZCBhbmQgY2FjaGVkLlxuICBjb25zdCBvcHRpb25zS2V5ID0gZ2V0S2V5Rm9yT3B0aW9ucyhvcHRpb25zKTtcblxuICAvLyBGaXJzdCBjaGVjayB0byBzZWUgaWYgd2UndmUgYWxyZWFkeSBkZXJpdmVkIGZyb20gdGhpcyBiYXNlTWF0ZXJpYWwgdXNpbmcgdGhpc1xuICAvLyB1bmlxdWUgc2V0IG9mIG9wdGlvbnMsIGFuZCBpZiBzbyByZXVzZSB0aGUgY29uc3RydWN0b3IgdG8gYXZvaWQgc29tZSBhbGxvY2F0aW9ucy5cbiAgbGV0IGN0b3JzQnlEZXJpdmF0aW9uID0gQ09OU1RSVUNUT1JfQ0FDSEUuZ2V0KGJhc2VNYXRlcmlhbCk7XG4gIGlmICghY3RvcnNCeURlcml2YXRpb24pIHtcbiAgICBDT05TVFJVQ1RPUl9DQUNIRS5zZXQoYmFzZU1hdGVyaWFsLCAoY3RvcnNCeURlcml2YXRpb24gPSBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gIH1cbiAgaWYgKGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldKSB7XG4gICAgcmV0dXJuIG5ldyBjdG9yc0J5RGVyaXZhdGlvbltvcHRpb25zS2V5XSgpXG4gIH1cblxuICBjb25zdCBwcml2YXRlQmVmb3JlQ29tcGlsZVByb3AgPSBgX29uQmVmb3JlQ29tcGlsZSR7b3B0aW9uc0tleX1gO1xuXG4gIC8vIFByaXZhdGUgb25CZWZvcmVDb21waWxlIGhhbmRsZXIgdGhhdCBpbmplY3RzIHRoZSBtb2RpZmllZCBzaGFkZXJzIGFuZCB1bmlmb3JtcyB3aGVuXG4gIC8vIHRoZSByZW5kZXJlciBzd2l0Y2hlcyB0byB0aGlzIG1hdGVyaWFsJ3MgcHJvZ3JhbVxuICBjb25zdCBvbkJlZm9yZUNvbXBpbGUgPSBmdW5jdGlvbiAoc2hhZGVySW5mbywgcmVuZGVyZXIpIHtcbiAgICBiYXNlTWF0ZXJpYWwub25CZWZvcmVDb21waWxlLmNhbGwodGhpcywgc2hhZGVySW5mbywgcmVuZGVyZXIpO1xuXG4gICAgLy8gVXBncmFkZSB0aGUgc2hhZGVycywgY2FjaGluZyB0aGUgcmVzdWx0IGJ5IGluY29taW5nIHNvdXJjZSBjb2RlXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpICsgJ3wnICsgc2hhZGVySW5mby52ZXJ0ZXhTaGFkZXIgKyAnfCcgKyBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyO1xuICAgIGxldCB1cGdyYWRlZFNoYWRlcnMgPSBTSEFERVJfVVBHUkFERV9DQUNIRVtjYWNoZUtleV07XG4gICAgaWYgKCF1cGdyYWRlZFNoYWRlcnMpIHtcbiAgICAgIGNvbnN0IHVwZ3JhZGVkID0gdXBncmFkZVNoYWRlcnModGhpcywgc2hhZGVySW5mbywgb3B0aW9ucywgb3B0aW9uc0tleSk7XG4gICAgICB1cGdyYWRlZFNoYWRlcnMgPSBTSEFERVJfVVBHUkFERV9DQUNIRVtjYWNoZUtleV0gPSB1cGdyYWRlZDtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgdXBncmFkZWQgc2hhZGVycyBhbmQgdW5pZm9ybXMgaW50byB0aGUgcHJvZ3JhbVxuICAgIHNoYWRlckluZm8udmVydGV4U2hhZGVyID0gdXBncmFkZWRTaGFkZXJzLnZlcnRleFNoYWRlcjtcbiAgICBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyID0gdXBncmFkZWRTaGFkZXJzLmZyYWdtZW50U2hhZGVyO1xuICAgIGFzc2lnbihzaGFkZXJJbmZvLnVuaWZvcm1zLCB0aGlzLnVuaWZvcm1zKTtcblxuICAgIC8vIEluamVjdCBhdXRvLXVwZGF0aW5nIHRpbWUgdW5pZm9ybSBpZiByZXF1ZXN0ZWRcbiAgICBpZiAob3B0aW9ucy50aW1lVW5pZm9ybSkge1xuICAgICAgc2hhZGVySW5mby51bmlmb3Jtc1tvcHRpb25zLnRpbWVVbmlmb3JtXSA9IHtcbiAgICAgICAgZ2V0IHZhbHVlKCkge3JldHVybiBEYXRlLm5vdygpIC0gZXBvY2h9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFVzZXJzIGNhbiBzdGlsbCBhZGQgdGhlaXIgb3duIGhhbmRsZXJzIG9uIHRvcCBvZiBvdXJzXG4gICAgaWYgKHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXSkge1xuICAgICAgdGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdKHNoYWRlckluZm8pO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBEZXJpdmVkTWF0ZXJpYWwgPSBmdW5jdGlvbiBEZXJpdmVkTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIGRlcml2ZShvcHRpb25zLmNoYWluZWQgPyBiYXNlTWF0ZXJpYWwgOiBiYXNlTWF0ZXJpYWwuY2xvbmUoKSlcbiAgfTtcblxuICBjb25zdCBkZXJpdmUgPSBmdW5jdGlvbihiYXNlKSB7XG4gICAgLy8gUHJvdG90eXBlIGNoYWluIHRvIHRoZSBiYXNlIG1hdGVyaWFsXG4gICAgY29uc3QgZGVyaXZlZCA9IE9iamVjdC5jcmVhdGUoYmFzZSwgZGVzY3JpcHRvcik7XG5cbiAgICAvLyBTdG9yZSB0aGUgYmFzZU1hdGVyaWFsIGZvciByZWZlcmVuY2U7IHRoaXMgaXMgYWx3YXlzIHRoZSBvcmlnaW5hbCBldmVuIHdoZW4gY2xvbmluZ1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXJpdmVkLCAnYmFzZU1hdGVyaWFsJywgeyB2YWx1ZTogYmFzZU1hdGVyaWFsIH0pO1xuXG4gICAgLy8gTmVlZHMgaXRzIG93biBpZHNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVyaXZlZCwgJ2lkJywgeyB2YWx1ZTogbWF0ZXJpYWxJbnN0YW5jZUlkKysgfSk7XG4gICAgZGVyaXZlZC51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICAvLyBNZXJnZSB1bmlmb3JtcywgZGVmaW5lcywgYW5kIGV4dGVuc2lvbnNcbiAgICBkZXJpdmVkLnVuaWZvcm1zID0gYXNzaWduKHt9LCBiYXNlLnVuaWZvcm1zLCBvcHRpb25zLnVuaWZvcm1zKTtcbiAgICBkZXJpdmVkLmRlZmluZXMgPSBhc3NpZ24oe30sIGJhc2UuZGVmaW5lcywgb3B0aW9ucy5kZWZpbmVzKTtcbiAgICBkZXJpdmVkLmRlZmluZXNbYFRST0lLQV9ERVJJVkVEX01BVEVSSUFMXyR7b3B0aW9uc0tleX1gXSA9ICcnOyAvL2ZvcmNlIGEgcHJvZ3JhbSBjaGFuZ2UgZnJvbSB0aGUgYmFzZSBtYXRlcmlhbFxuICAgIGRlcml2ZWQuZXh0ZW5zaW9ucyA9IGFzc2lnbih7fSwgYmFzZS5leHRlbnNpb25zLCBvcHRpb25zLmV4dGVuc2lvbnMpO1xuXG4gICAgLy8gRG9uJ3QgaW5oZXJpdCBFdmVudERpc3BhdGNoZXIgbGlzdGVuZXJzXG4gICAgZGVyaXZlZC5fbGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGRlcml2ZWRcbiAgfTtcblxuICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgIGNvbnN0cnVjdG9yOiB7dmFsdWU6IERlcml2ZWRNYXRlcmlhbH0sXG4gICAgaXNEZXJpdmVkTWF0ZXJpYWw6IHt2YWx1ZTogdHJ1ZX0sXG5cbiAgICB0eXBlOiB7XG4gICAgICBnZXQ6ICgpID0+IGJhc2VNYXRlcmlhbC50eXBlLFxuICAgICAgc2V0OiAodmFsdWUpID0+IHtiYXNlTWF0ZXJpYWwudHlwZSA9IHZhbHVlO31cbiAgICB9LFxuXG4gICAgaXNEZXJpdmVkRnJvbToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHRlc3RNYXRlcmlhbCkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5iYXNlTWF0ZXJpYWw7XG4gICAgICAgIHJldHVybiB0ZXN0TWF0ZXJpYWwgPT09IGJhc2UgfHwgKGJhc2UuaXNEZXJpdmVkTWF0ZXJpYWwgJiYgYmFzZS5pc0Rlcml2ZWRGcm9tKHRlc3RNYXRlcmlhbCkpIHx8IGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGN1c3RvbVByb2dyYW1DYWNoZUtleToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYmFzZU1hdGVyaWFsLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpICsgJ3wnICsgb3B0aW9uc0tleVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkJlZm9yZUNvbXBpbGU6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG9uQmVmb3JlQ29tcGlsZVxuICAgICAgfSxcbiAgICAgIHNldChmbikge1xuICAgICAgICB0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0gPSBmbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBiYXNlTWF0ZXJpYWwuY29weS5jYWxsKHRoaXMsIHNvdXJjZSk7XG4gICAgICAgIGlmICghYmFzZU1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgIWJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbCkge1xuICAgICAgICAgIGFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIHNvdXJjZS5leHRlbnNpb25zKTtcbiAgICAgICAgICBhc3NpZ24odGhpcy5kZWZpbmVzLCBzb3VyY2UuZGVmaW5lcyk7XG4gICAgICAgICAgYXNzaWduKHRoaXMudW5pZm9ybXMsIFVuaWZvcm1zVXRpbHMuY2xvbmUoc291cmNlLnVuaWZvcm1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xvbmU6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbmV3QmFzZSA9IG5ldyBiYXNlTWF0ZXJpYWwuY29uc3RydWN0b3IoKTtcbiAgICAgICAgcmV0dXJuIGRlcml2ZShuZXdCYXNlKS5jb3B5KHRoaXMpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERlcHRoTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgKi9cbiAgICBnZXREZXB0aE1hdGVyaWFsOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGRlcHRoTWF0ZXJpYWwgPSB0aGlzLl9kZXB0aE1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRlcHRoTWF0ZXJpYWwpIHtcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsID0gdGhpcy5fZGVwdGhNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICA/IGJhc2VNYXRlcmlhbC5nZXREZXB0aE1hdGVyaWFsKClcbiAgICAgICAgICAgICAgOiBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoeyBkZXB0aFBhY2tpbmc6IFJHQkFEZXB0aFBhY2tpbmcgfSksXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsLmRlZmluZXMuSVNfREVQVEhfTUFURVJJQUwgPSAnJztcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtczsgLy9hdXRvbWF0aWNhbGx5IHJlY2lldmUgc2FtZSB1bmlmb3JtIHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXB0aE1hdGVyaWFsXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERpc3RhbmNlTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgKi9cbiAgICBnZXREaXN0YW5jZU1hdGVyaWFsOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGRpc3RhbmNlTWF0ZXJpYWwgPSB0aGlzLl9kaXN0YW5jZU1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRpc3RhbmNlTWF0ZXJpYWwpIHtcbiAgICAgICAgICBkaXN0YW5jZU1hdGVyaWFsID0gdGhpcy5fZGlzdGFuY2VNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICA/IGJhc2VNYXRlcmlhbC5nZXREaXN0YW5jZU1hdGVyaWFsKClcbiAgICAgICAgICAgICAgOiBuZXcgTWVzaERpc3RhbmNlTWF0ZXJpYWwoKSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwuZGVmaW5lcy5JU19ESVNUQU5DRV9NQVRFUklBTCA9ICcnO1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zOyAvL2F1dG9tYXRpY2FsbHkgcmVjaWV2ZSBzYW1lIHVuaWZvcm0gdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlTWF0ZXJpYWxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcG9zZToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZSgpIHtcbiAgICAgICAgY29uc3Qge19kZXB0aE1hdGVyaWFsLCBfZGlzdGFuY2VNYXRlcmlhbH0gPSB0aGlzO1xuICAgICAgICBpZiAoX2RlcHRoTWF0ZXJpYWwpIF9kZXB0aE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKF9kaXN0YW5jZU1hdGVyaWFsKSBfZGlzdGFuY2VNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldID0gRGVyaXZlZE1hdGVyaWFsO1xuICByZXR1cm4gbmV3IERlcml2ZWRNYXRlcmlhbCgpXG59XG5cblxuZnVuY3Rpb24gdXBncmFkZVNoYWRlcnMobWF0ZXJpYWwsIHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSwgb3B0aW9ucywga2V5KSB7XG4gIGxldCB7XG4gICAgdmVydGV4RGVmcyxcbiAgICB2ZXJ0ZXhNYWluSW50cm8sXG4gICAgdmVydGV4TWFpbk91dHJvLFxuICAgIHZlcnRleFRyYW5zZm9ybSxcbiAgICBmcmFnbWVudERlZnMsXG4gICAgZnJhZ21lbnRNYWluSW50cm8sXG4gICAgZnJhZ21lbnRNYWluT3V0cm8sXG4gICAgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSxcbiAgICBjdXN0b21SZXdyaXRlcixcbiAgICB0aW1lVW5pZm9ybVxuICB9ID0gb3B0aW9ucztcblxuICB2ZXJ0ZXhEZWZzID0gdmVydGV4RGVmcyB8fCAnJztcbiAgdmVydGV4TWFpbkludHJvID0gdmVydGV4TWFpbkludHJvIHx8ICcnO1xuICB2ZXJ0ZXhNYWluT3V0cm8gPSB2ZXJ0ZXhNYWluT3V0cm8gfHwgJyc7XG4gIGZyYWdtZW50RGVmcyA9IGZyYWdtZW50RGVmcyB8fCAnJztcbiAgZnJhZ21lbnRNYWluSW50cm8gPSBmcmFnbWVudE1haW5JbnRybyB8fCAnJztcbiAgZnJhZ21lbnRNYWluT3V0cm8gPSBmcmFnbWVudE1haW5PdXRybyB8fCAnJztcblxuICAvLyBFeHBhbmQgaW5jbHVkZXMgaWYgbmVlZGVkXG4gIGlmICh2ZXJ0ZXhUcmFuc2Zvcm0gfHwgY3VzdG9tUmV3cml0ZXIpIHtcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBleHBhbmRTaGFkZXJJbmNsdWRlcyh2ZXJ0ZXhTaGFkZXIpO1xuICB9XG4gIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtIHx8IGN1c3RvbVJld3JpdGVyKSB7XG4gICAgLy8gV2UgbmVlZCB0byBiZSBhYmxlIHRvIGZpbmQgcG9zdHByb2Nlc3NpbmcgY2h1bmtzIGFmdGVyIGluY2x1ZGUgZXhwYW5zaW9uIGluIG9yZGVyIHRvXG4gICAgLy8gcHV0IHRoZW0gYWZ0ZXIgdGhlIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0sIHNvIG1hcmsgdGhlbSB3aXRoIGNvbW1lbnRzIGZpcnN0LiBFdmVuIGlmXG4gICAgLy8gdGhpcyBwYXJ0aWN1bGFyIGRlcml2YXRpb24gZG9lc24ndCBoYXZlIGEgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSwgb3RoZXIgZGVyaXZhdGlvbnMgbWF5LFxuICAgIC8vIHNvIHdlIHN0aWxsIG1hcmsgdGhlbS5cbiAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXG4gICAgICAvXlsgXFx0XSojaW5jbHVkZSA8KCg/OnRvbmVtYXBwaW5nfGVuY29kaW5nc3xjb2xvcnNwYWNlfGZvZ3xwcmVtdWx0aXBsaWVkX2FscGhhfGRpdGhlcmluZylfZnJhZ21lbnQpPi9nbSxcbiAgICAgICdcXG4vLyFCRUdJTl9QT1NUX0NIVU5LICQxXFxuJCZcXG4vLyFFTkRfUE9TVF9DSFVOS1xcbidcbiAgICApO1xuICAgIGZyYWdtZW50U2hhZGVyID0gZXhwYW5kU2hhZGVySW5jbHVkZXMoZnJhZ21lbnRTaGFkZXIpO1xuICB9XG5cbiAgLy8gQXBwbHkgY3VzdG9tIHJld3JpdGVyIGZ1bmN0aW9uXG4gIGlmIChjdXN0b21SZXdyaXRlcikge1xuICAgIGxldCByZXMgPSBjdXN0b21SZXdyaXRlcih7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn0pO1xuICAgIHZlcnRleFNoYWRlciA9IHJlcy52ZXJ0ZXhTaGFkZXI7XG4gICAgZnJhZ21lbnRTaGFkZXIgPSByZXMuZnJhZ21lbnRTaGFkZXI7XG4gIH1cblxuICAvLyBUaGUgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSBuZWVkcyB0byBnbyBiZWZvcmUgYW55IHBvc3Rwcm9jZXNzaW5nIGNodW5rcywgc28gZXh0cmFjdFxuICAvLyB0aG9zZSBhbmQgcmUtaW5zZXJ0IHRoZW0gaW50byB0aGUgb3V0cm8gaW4gdGhlIGNvcnJlY3QgcGxhY2U6XG4gIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtKSB7XG4gICAgbGV0IHBvc3RDaHVua3MgPSBbXTtcbiAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXG4gICAgICAvXlxcL1xcLyFCRUdJTl9QT1NUX0NIVU5LW15dKz9eXFwvXFwvIUVORF9QT1NUX0NIVU5LL2dtLCAvLyBbXl0rPyA9IG5vbi1ncmVlZHkgbWF0Y2ggb2YgYW55IGNoYXJzIGluY2x1ZGluZyBuZXdsaW5lc1xuICAgICAgbWF0Y2ggPT4ge1xuICAgICAgICBwb3N0Q2h1bmtzLnB1c2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cbiAgICApO1xuICAgIGZyYWdtZW50TWFpbk91dHJvID0gYCR7ZnJhZ21lbnRDb2xvclRyYW5zZm9ybX1cXG4ke3Bvc3RDaHVua3Muam9pbignXFxuJyl9XFxuJHtmcmFnbWVudE1haW5PdXRyb31gO1xuICB9XG5cbiAgLy8gSW5qZWN0IGF1dG8tdXBkYXRpbmcgdGltZSB1bmlmb3JtIGlmIHJlcXVlc3RlZFxuICBpZiAodGltZVVuaWZvcm0pIHtcbiAgICBjb25zdCBjb2RlID0gYFxcbnVuaWZvcm0gZmxvYXQgJHt0aW1lVW5pZm9ybX07XFxuYDtcbiAgICB2ZXJ0ZXhEZWZzID0gY29kZSArIHZlcnRleERlZnM7XG4gICAgZnJhZ21lbnREZWZzID0gY29kZSArIGZyYWdtZW50RGVmcztcbiAgfVxuXG4gIC8vIEluamVjdCBhIGZ1bmN0aW9uIGZvciB0aGUgdmVydGV4VHJhbnNmb3JtIGFuZCByZW5hbWUgYWxsIHVzYWdlcyBvZiBwb3NpdGlvbi9ub3JtYWwvdXZcbiAgaWYgKHZlcnRleFRyYW5zZm9ybSkge1xuICAgIC8vIEhvaXN0IHRoZXNlIGRlZnMgdG8gdGhlIHZlcnkgdG9wIHNvIHRoZXkgd29yayBpbiBvdGhlciBmdW5jdGlvbiBkZWZzXG4gICAgdmVydGV4U2hhZGVyID0gYHZlYzMgdHJvaWthX3Bvc2l0aW9uXyR7a2V5fTtcbnZlYzMgdHJvaWthX25vcm1hbF8ke2tleX07XG52ZWMyIHRyb2lrYV91dl8ke2tleX07XG4ke3ZlcnRleFNoYWRlcn1cbmA7XG4gICAgdmVydGV4RGVmcyA9IGAke3ZlcnRleERlZnN9XG52b2lkIHRyb2lrYVZlcnRleFRyYW5zZm9ybSR7a2V5fShpbm91dCB2ZWMzIHBvc2l0aW9uLCBpbm91dCB2ZWMzIG5vcm1hbCwgaW5vdXQgdmVjMiB1dikge1xuICAke3ZlcnRleFRyYW5zZm9ybX1cbn1cbmA7XG4gICAgdmVydGV4TWFpbkludHJvID0gYFxudHJvaWthX3Bvc2l0aW9uXyR7a2V5fSA9IHZlYzMocG9zaXRpb24pO1xudHJvaWthX25vcm1hbF8ke2tleX0gPSB2ZWMzKG5vcm1hbCk7XG50cm9pa2FfdXZfJHtrZXl9ID0gdmVjMih1dik7XG50cm9pa2FWZXJ0ZXhUcmFuc2Zvcm0ke2tleX0odHJvaWthX3Bvc2l0aW9uXyR7a2V5fSwgdHJvaWthX25vcm1hbF8ke2tleX0sIHRyb2lrYV91dl8ke2tleX0pO1xuJHt2ZXJ0ZXhNYWluSW50cm99XG5gO1xuICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKC9cXGIocG9zaXRpb258bm9ybWFsfHV2KVxcYi9nLCAobWF0Y2gsIG1hdGNoMSwgaW5kZXgsIGZ1bGxTdHIpID0+IHtcbiAgICAgIHJldHVybiAvXFxiYXR0cmlidXRlXFxzK3ZlY1syM11cXHMrJC8udGVzdChmdWxsU3RyLnN1YnN0cigwLCBpbmRleCkpID8gbWF0Y2gxIDogYHRyb2lrYV8ke21hdGNoMX1fJHtrZXl9YFxuICAgIH0pO1xuXG4gICAgLy8gVGhyZWUgcjE1MiBpbnRyb2R1Y2VkIHRoZSBNQVBfVVYgdG9rZW4sIHJlcGxhY2UgaXQgdG9vIGlmIGl0J3MgcG9pbnRpbmcgdG8gdGhlIG1haW4gJ3V2J1xuICAgIC8vIFBlcmhhcHMgdGhlIG90aGVyIHRleHR1cmVzIHRvbyBnb2luZyBmb3J3YXJkP1xuICAgIGlmICghKG1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuY2hhbm5lbCA+IDApKSB7XG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZSgvXFxiTUFQX1VWXFxiL2csIGB0cm9pa2FfdXZfJHtrZXl9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5qZWN0IGRlZnMgYW5kIGludHJvL291dHJvIHNuaXBwZXRzXG4gIHZlcnRleFNoYWRlciA9IGluamVjdEludG9TaGFkZXJDb2RlKHZlcnRleFNoYWRlciwga2V5LCB2ZXJ0ZXhEZWZzLCB2ZXJ0ZXhNYWluSW50cm8sIHZlcnRleE1haW5PdXRybyk7XG4gIGZyYWdtZW50U2hhZGVyID0gaW5qZWN0SW50b1NoYWRlckNvZGUoZnJhZ21lbnRTaGFkZXIsIGtleSwgZnJhZ21lbnREZWZzLCBmcmFnbWVudE1haW5JbnRybywgZnJhZ21lbnRNYWluT3V0cm8pO1xuXG4gIHJldHVybiB7XG4gICAgdmVydGV4U2hhZGVyLFxuICAgIGZyYWdtZW50U2hhZGVyXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b1NoYWRlckNvZGUoc2hhZGVyQ29kZSwgaWQsIGRlZnMsIGludHJvLCBvdXRybykge1xuICBpZiAoaW50cm8gfHwgb3V0cm8gfHwgZGVmcykge1xuICAgIHNoYWRlckNvZGUgPSBzaGFkZXJDb2RlLnJlcGxhY2Uodm9pZE1haW5SZWdFeHAsIGBcbiR7ZGVmc31cbnZvaWQgdHJvaWthT3JpZ01haW4ke2lkfSgpIHtgXG4gICAgKTtcbiAgICBzaGFkZXJDb2RlICs9IGBcbnZvaWQgbWFpbigpIHtcbiAgJHtpbnRyb31cbiAgdHJvaWthT3JpZ01haW4ke2lkfSgpO1xuICAke291dHJvfVxufWA7XG4gIH1cbiAgcmV0dXJuIHNoYWRlckNvZGVcbn1cblxuXG5mdW5jdGlvbiBvcHRpb25zSnNvblJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ3VuaWZvcm1zJyA/IHVuZGVmaW5lZCA6IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZVxufVxuXG5sZXQgX2lkQ3RyID0gMDtcbmNvbnN0IG9wdGlvbnNIYXNoZXNUb0lkcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEtleUZvck9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zSGFzaCA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIG9wdGlvbnNKc29uUmVwbGFjZXIpO1xuICBsZXQgaWQgPSBvcHRpb25zSGFzaGVzVG9JZHMuZ2V0KG9wdGlvbnNIYXNoKTtcbiAgaWYgKGlkID09IG51bGwpIHtcbiAgICBvcHRpb25zSGFzaGVzVG9JZHMuc2V0KG9wdGlvbnNIYXNoLCAoaWQgPSArK19pZEN0cikpO1xuICB9XG4gIHJldHVybiBpZFxufVxuXG4vLyBDb3BpZWQgZnJvbSB0aHJlZWpzIFdlYkdMUHJvZ3JhbXMuanMgc28gd2UgY2FuIHJlc29sdmUgYnVpbHRpbiBtYXRlcmlhbHMgdG8gdGhlaXIgc2hhZGVyc1xuLy8gVE9ETyBob3cgY2FuIHdlIGtlZXAgdGhpcyBmcm9tIGdldHRpbmcgc3RhbGU/XG5jb25zdCBNQVRFUklBTF9UWVBFU19UT19TSEFERVJTID0ge1xuICBNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcbiAgTWVzaERpc3RhbmNlTWF0ZXJpYWw6ICdkaXN0YW5jZVJHQkEnLFxuICBNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxuICBNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgTWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuICBNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcbiAgTWVzaFRvb25NYXRlcmlhbDogJ3Rvb24nLFxuICBNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgTWVzaFBoeXNpY2FsTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG4gIE1lc2hNYXRjYXBNYXRlcmlhbDogJ21hdGNhcCcsXG4gIExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICBMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxuICBQb2ludHNNYXRlcmlhbDogJ3BvaW50cycsXG4gIFNoYWRvd01hdGVyaWFsOiAnc2hhZG93JyxcbiAgU3ByaXRlTWF0ZXJpYWw6ICdzcHJpdGUnXG59O1xuXG4vKipcbiAqIEdpdmVuIGEgVGhyZWUuanMgYE1hdGVyaWFsYCBpbnN0YW5jZSwgZmluZCB0aGUgc2hhZGVycy91bmlmb3JtcyB0aGF0IHdpbGwgYmVcbiAqIHVzZWQgdG8gcmVuZGVyIHRoYXQgbWF0ZXJpYWwuXG4gKlxuICogQHBhcmFtIG1hdGVyaWFsIC0gdGhlIE1hdGVyaWFsIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gdGhlIG1hdGVyaWFsJ3Mgc2hhZGVyIGluZm86IGB7dW5pZm9ybXM6e30sIGZyYWdtZW50U2hhZGVyOicnLCB2ZXJ0ZXhTaGFkZXI6Jyd9YFxuICovXG5mdW5jdGlvbiBnZXRTaGFkZXJzRm9yTWF0ZXJpYWwobWF0ZXJpYWwpIHtcbiAgbGV0IGJ1aWx0aW5UeXBlID0gTUFURVJJQUxfVFlQRVNfVE9fU0hBREVSU1ttYXRlcmlhbC50eXBlXTtcbiAgcmV0dXJuIGJ1aWx0aW5UeXBlID8gU2hhZGVyTGliW2J1aWx0aW5UeXBlXSA6IG1hdGVyaWFsIC8vVE9ETyBmYWxsYmFjayBmb3IgdW5rbm93biB0eXBlP1xufVxuXG4vKipcbiAqIEZpbmQgYWxsIHVuaWZvcm1zIGFuZCB0aGVpciB0eXBlcyB3aXRoaW4gYSBzaGFkZXIgY29kZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlciAtIFRoZSBzaGFkZXIgY29kZSB0byBwYXJzZVxuICogQHJldHVybiB7b2JqZWN0fSBtYXBwaW5nIG9mIHVuaWZvcm0gbmFtZXMgdG8gdGhlaXIgZ2xzbCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGdldFNoYWRlclVuaWZvcm1UeXBlcyhzaGFkZXIpIHtcbiAgbGV0IHVuaWZvcm1SRSA9IC9cXGJ1bmlmb3JtXFxzKyhpbnR8ZmxvYXR8dmVjWzIzNF18bWF0WzM0XSlcXHMrKFtBLVphLXpfXVtcXHddKikvZztcbiAgbGV0IHVuaWZvcm1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gdW5pZm9ybVJFLmV4ZWMoc2hhZGVyKSkgIT09IG51bGwpIHtcbiAgICB1bmlmb3Jtc1ttYXRjaFsyXV0gPSBtYXRjaFsxXTtcbiAgfVxuICByZXR1cm4gdW5pZm9ybXNcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHNtb290aGluZyBvdXQgdGhlIGBtLmdldEludmVyc2UoeClgIC0tPiBgbS5jb3B5KHgpLmludmVydCgpYCBjb252ZXJzaW9uXG4gKiB0aGF0IGhhcHBlbmVkIGluIFRocmVlSlMgcjEyMy5cbiAqIEBwYXJhbSB7TWF0cml4NH0gc3JjTWF0cml4XG4gKiBAcGFyYW0ge01hdHJpeDR9IFt0Z3RNYXRyaXhdXG4gKi9cbmZ1bmN0aW9uIGludmVydE1hdHJpeDQoc3JjTWF0cml4LCB0Z3RNYXRyaXggPSBuZXcgTWF0cml4NCgpKSB7XG4gIGlmICh0eXBlb2YgdGd0TWF0cml4LmludmVydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRndE1hdHJpeC5jb3B5KHNyY01hdHJpeCkuaW52ZXJ0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGd0TWF0cml4LmdldEludmVyc2Uoc3JjTWF0cml4KTtcbiAgfVxuICByZXR1cm4gdGd0TWF0cml4XG59XG5cbi8qXG5JbnB1dCBnZW9tZXRyeSBpcyBhIGN5bGluZGVyIHdpdGggcj0xLCBoZWlnaHQgaW4geSBkaW1lbnNpb24gZnJvbSAwIHRvIDEsXG5kaXZpZGVkIGludG8gYSByZWFzb25hYmxlIG51bWJlciBvZiBoZWlnaHQgc2VnbWVudHMuXG4qL1xuXG5jb25zdCB2ZXJ0ZXhEZWZzID0gYFxudW5pZm9ybSB2ZWMzIHBvaW50QTtcbnVuaWZvcm0gdmVjMyBjb250cm9sQTtcbnVuaWZvcm0gdmVjMyBjb250cm9sQjtcbnVuaWZvcm0gdmVjMyBwb2ludEI7XG51bmlmb3JtIGZsb2F0IHJhZGl1cztcbnZhcnlpbmcgZmxvYXQgYmV6aWVyVDtcblxudmVjMyBjdWJpY0Jlemllcih2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XG4gIGZsb2F0IHQyID0gMS4wIC0gdDtcbiAgZmxvYXQgYjAgPSB0MiAqIHQyICogdDI7XG4gIGZsb2F0IGIxID0gMy4wICogdCAqIHQyICogdDI7XG4gIGZsb2F0IGIyID0gMy4wICogdCAqIHQgKiB0MjtcbiAgZmxvYXQgYjMgPSB0ICogdCAqIHQ7XG4gIHJldHVybiBiMCAqIHAxICsgYjEgKiBjMSArIGIyICogYzIgKyBiMyAqIHAyO1xufVxuXG52ZWMzIGN1YmljQmV6aWVyRGVyaXZhdGl2ZSh2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XG4gIGZsb2F0IHQyID0gMS4wIC0gdDtcbiAgcmV0dXJuIC0zLjAgKiBwMSAqIHQyICogdDIgK1xuICAgIGMxICogKDMuMCAqIHQyICogdDIgLSA2LjAgKiB0MiAqIHQpICtcbiAgICBjMiAqICg2LjAgKiB0MiAqIHQgLSAzLjAgKiB0ICogdCkgK1xuICAgIDMuMCAqIHAyICogdCAqIHQ7XG59XG5gO1xuXG5jb25zdCB2ZXJ0ZXhUcmFuc2Zvcm0gPSBgXG5mbG9hdCB0ID0gcG9zaXRpb24ueTtcbmJlemllclQgPSB0O1xudmVjMyBiZXppZXJDZW50ZXJQb3MgPSBjdWJpY0Jlemllcihwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KTtcbnZlYzMgYmV6aWVyRGlyID0gbm9ybWFsaXplKGN1YmljQmV6aWVyRGVyaXZhdGl2ZShwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KSk7XG5cbi8vIE1ha2UgXCJzaWRld2F5c1wiIGFsd2F5cyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBjYW1lcmEgcmF5OyB0aGlzIGVuc3VyZXMgdGhhdCBhbnkgdHdpc3RzXG4vLyBpbiB0aGUgY3lsaW5kZXIgb2NjdXIgd2hlcmUgeW91IHdvbid0IHNlZSB0aGVtOiBcbnZlYzMgdmlld0RpcmVjdGlvbiA9IG5vcm1hbE1hdHJpeCAqIHZlYzMoMC4wLCAwLjAsIDEuMCk7XG5pZiAoYmV6aWVyRGlyID09IHZpZXdEaXJlY3Rpb24pIHtcbiAgYmV6aWVyRGlyID0gbm9ybWFsaXplKGN1YmljQmV6aWVyRGVyaXZhdGl2ZShwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0ID09IDEuMCA/IHQgLSAwLjAwMDEgOiB0ICsgMC4wMDAxKSk7XG59XG52ZWMzIHNpZGV3YXlzID0gbm9ybWFsaXplKGNyb3NzKGJlemllckRpciwgdmlld0RpcmVjdGlvbikpO1xudmVjMyB1cGlzaCA9IG5vcm1hbGl6ZShjcm9zcyhzaWRld2F5cywgYmV6aWVyRGlyKSk7XG5cbi8vIEJ1aWxkIGEgbWF0cml4IGZvciB0cmFuc2Zvcm1pbmcgdGhpcyBkaXNjIGluIHRoZSBjeWxpbmRlcjpcbm1hdDQgZGlzY1R4O1xuZGlzY1R4WzBdLnh5eiA9IHNpZGV3YXlzICogcmFkaXVzO1xuZGlzY1R4WzFdLnh5eiA9IGJlemllckRpciAqIHJhZGl1cztcbmRpc2NUeFsyXS54eXogPSB1cGlzaCAqIHJhZGl1cztcbmRpc2NUeFszXS54eXogPSBiZXppZXJDZW50ZXJQb3M7XG5kaXNjVHhbM11bM10gPSAxLjA7XG5cbi8vIEFwcGx5IHRyYW5zZm9ybSwgaWdub3Jpbmcgb3JpZ2luYWwgeVxucG9zaXRpb24gPSAoZGlzY1R4ICogdmVjNChwb3NpdGlvbi54LCAwLjAsIHBvc2l0aW9uLnosIDEuMCkpLnh5ejtcbm5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKGRpc2NUeCkgKiBub3JtYWwpO1xuYDtcblxuY29uc3QgZnJhZ21lbnREZWZzID0gYFxudW5pZm9ybSB2ZWMzIGRhc2hpbmc7XG52YXJ5aW5nIGZsb2F0IGJlemllclQ7XG5gO1xuXG5jb25zdCBmcmFnbWVudE1haW5JbnRybyA9IGBcbmlmIChkYXNoaW5nLnggKyBkYXNoaW5nLnkgPiAwLjApIHtcbiAgZmxvYXQgZGFzaEZyYWMgPSBtb2QoYmV6aWVyVCAtIGRhc2hpbmcueiwgZGFzaGluZy54ICsgZGFzaGluZy55KTtcbiAgaWYgKGRhc2hGcmFjID4gZGFzaGluZy54KSB7XG4gICAgZGlzY2FyZDtcbiAgfVxufVxuYDtcblxuLy8gRGVidWdnaW5nOiBzZXBhcmF0ZSBjb2xvciBmb3IgZWFjaCBvZiB0aGUgNiBzaWRlczpcbi8vIGNvbnN0IGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gPSBgXG4vLyBmbG9hdCBzaWRlTnVtID0gZmxvb3IodlVWLnggKiA2LjApO1xuLy8gdmVjMyBtaXhDb2xvciA9IHNpZGVOdW0gPCAxLjAgPyB2ZWMzKDEuMCwgMC4wLCAwLjApIDpcbi8vICAgc2lkZU51bSA8IDIuMCA/IHZlYzMoMC4wLCAxLjAsIDEuMCkgOlxuLy8gICBzaWRlTnVtIDwgMy4wID8gdmVjMygxLjAsIDEuMCwgMC4wKSA6XG4vLyAgIHNpZGVOdW0gPCA0LjAgPyB2ZWMzKDAuMCwgMC4wLCAxLjApIDpcbi8vICAgc2lkZU51bSA8IDUuMCA/IHZlYzMoMC4wLCAxLjAsIDAuMCkgOlxuLy8gICB2ZWMzKDEuMCwgMC4wLCAxLjApO1xuLy8gZ2xfRnJhZ0NvbG9yLnh5eiA9IG1peChnbF9GcmFnQ29sb3IueHl6LCBtaXhDb2xvciwgMC41KTtcbi8vIGBcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUJlemllck1lc2hNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgcmV0dXJuIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICBiYXNlTWF0ZXJpYWwsXG4gICAge1xuICAgICAgY2hhaW5lZDogdHJ1ZSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHBvaW50QToge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSxcbiAgICAgICAgY29udHJvbEE6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIGNvbnRyb2xCOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9LFxuICAgICAgICBwb2ludEI6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIHJhZGl1czoge3ZhbHVlOiAwLjAxfSxcbiAgICAgICAgZGFzaGluZzoge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSAvL29uLCBvZmYsIG9mZnNldFxuICAgICAgfSxcbiAgICAgIHZlcnRleERlZnMsXG4gICAgICB2ZXJ0ZXhUcmFuc2Zvcm0sXG4gICAgICBmcmFnbWVudERlZnMsXG4gICAgICBmcmFnbWVudE1haW5JbnRyb1xuICAgIH1cbiAgKVxufVxuXG5sZXQgZ2VvbWV0cnkgPSBudWxsO1xuXG5jb25zdCBkZWZhdWx0QmFzZU1hdGVyaWFsID0gLyojX19QVVJFX18qL25ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7Y29sb3I6IDB4ZmZmZmZmLCBzaWRlOiBEb3VibGVTaWRlfSk7XG5cblxuLyoqXG4gKiBBIFRocmVlSlMgYE1lc2hgIHRoYXQgYmVuZHMgYSB0dWJlIHNoYXBlIGFsb25nIGEgM0QgY3ViaWMgYmV6aWVyIHBhdGguIFRoZSBiZW5kaW5nIGlzIGRvbmVcbiAqIGJ5IGRlZm9ybWluZyBhIHN0cmFpZ2h0IGN5bGluZHJpY2FsIGdlb21ldHJ5IGluIHRoZSB2ZXJ0ZXggc2hhZGVyIGJhc2VkIG9uIGEgc2V0IG9mIGZvdXJcbiAqIGNvbnRyb2wgcG9pbnQgdW5pZm9ybXMuIEl0IHBhdGNoZXMgdGhlIG5lY2Vzc2FyeSBHTFNMIGludG8gdGhlIG1lc2gncyBhc3NpZ25lZCBgbWF0ZXJpYWxgXG4gKiBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIFRoZSBjdWJpeiBiZXppZXIgcGF0aCBpcyBkZXRlcm1pbmVkIGJ5IGl0cyBmb3VyIGBWZWN0b3IzYCBwcm9wZXJ0aWVzOlxuICogLSBgcG9pbnRBYFxuICogLSBgY29udHJvbEFgXG4gKiAtIGBjb250cm9sQmBcbiAqIC0gYHBvaW50QmBcbiAqXG4gKiBUaGUgdHViZSdzIHJhZGl1cyBpcyBjb250cm9sbGVkIGJ5IGl0cyBgcmFkaXVzYCBwcm9wZXJ0eSwgd2hpY2ggZGVmYXVsdHMgdG8gYDAuMDFgLlxuICpcbiAqIFlvdSBjYW4gYWxzbyBnaXZlIHRoZSB0dWJlIGEgZGFzaGVkIGFwcGVhcmFuY2Ugd2l0aCB0d28gcHJvcGVydGllczpcbiAqXG4gKiAtIGBkYXNoQXJyYXlgIC0gYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMsIGRlZmluaW5nIHRoZSBsZW5ndGggb2YgXCJvblwiIGFuZCBcIm9mZlwiIHBhcnRzIG9mXG4gKiAgIHRoZSBkYXNoLiBFYWNoIGlzIGEgMC0xIHJhdGlvIG9mIHRoZSBlbnRpcmUgcGF0aCdzIGxlbmd0aC4gKEFjdHVhbGx5IHRoaXMgaXMgdGhlIGB0YCBsZW5ndGhcbiAqICAgdXNlZCBhcyBpbnB1dCB0byB0aGUgY3ViaWMgYmV6aWVyIGZ1bmN0aW9uLCBub3QgaXRzIHZpc2libGUgbGVuZ3RoLilcbiAqIC0gYGRhc2hPZmZzZXRgIC0gb2Zmc2V0IG9mIHdoZXJlIHRoZSBkYXNoIHN0YXJ0cy4gWW91IGNhbiBhbmltYXRlIHRoaXMgdG8gbWFrZSB0aGUgZGFzaGVzIG1vdmUuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBkYXNoZXMgd2lsbCBhcHBlYXIgbGlrZSBhIGhvbGxvdyB0dWJlLCBub3Qgc29saWQuIFRoaXMgd2lsbCBiZSBtb3JlIGFwcGFyZW50IG9uXG4gKiB0aGlja2VyIHR1YmVzLlxuICpcbiAqIFRPRE86IHByb3BlciBnZW9tZXRyeSBib3VuZGluZyBzcGhlcmUgYW5kIHJheWNhc3RpbmdcbiAqIFRPRE86IGFsbG93IGNvbnRyb2wgb2YgdGhlIGdlb21ldHJ5J3Mgc2VnbWVudCBjb3VudHNcbiAqL1xuY2xhc3MgQmV6aWVyTWVzaCBleHRlbmRzIE1lc2gge1xuICBzdGF0aWMgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIGdlb21ldHJ5IHx8IChnZW9tZXRyeSA9XG4gICAgICBuZXcgQ3lsaW5kZXJHZW9tZXRyeSgxLCAxLCAxLCA2LCA2NCkudHJhbnNsYXRlKDAsIDAuNSwgMClcbiAgICApXG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcbiAgICAgIEJlemllck1lc2guZ2V0R2VvbWV0cnkoKSxcbiAgICAgIGRlZmF1bHRCYXNlTWF0ZXJpYWxcbiAgICApO1xuXG4gICAgdGhpcy5wb2ludEEgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY29udHJvbEEgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY29udHJvbEIgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMucG9pbnRCID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLnJhZGl1cyA9IDAuMDE7XG4gICAgdGhpcy5kYXNoQXJyYXkgPSBuZXcgVmVjdG9yMigpO1xuICAgIHRoaXMuZGFzaE9mZnNldCA9IDA7XG5cbiAgICAvLyBUT0RPIC0gZGlzYWJsaW5nIGZydXN0dW0gY3VsbGluZyB1bnRpbCBJIGZpZ3VyZSBvdXQgaG93IHRvIGN1c3RvbWl6ZSB0aGVcbiAgICAvLyAgZ2VvbWV0cnkncyBib3VuZGluZyBzcGhlcmUgdGhhdCBnZXRzIHVzZWRcbiAgICB0aGlzLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEhhbmRsZXIgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgdGhlIGJhc2UgbWF0ZXJpYWwgd2l0aCBvdXIgdXBncmFkZXMuIFdlIGRvIHRoZSB3cmFwcGluZ1xuICAvLyBsYXppbHkgb24gX3JlYWRfIHJhdGhlciB0aGFuIHdyaXRlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdyYXBwaW5nIG9uIHRyYW5zaWVudCB2YWx1ZXMuXG4gIGdldCBtYXRlcmlhbCgpIHtcbiAgICBsZXQgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsO1xuICAgIGNvbnN0IGJhc2VNYXRlcmlhbCA9IHRoaXMuX2Jhc2VNYXRlcmlhbCB8fCB0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgfHwgKHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IGRlZmF1bHRCYXNlTWF0ZXJpYWwuY2xvbmUoKSk7XG4gICAgaWYgKCFkZXJpdmVkTWF0ZXJpYWwgfHwgZGVyaXZlZE1hdGVyaWFsLmJhc2VNYXRlcmlhbCAhPT0gYmFzZU1hdGVyaWFsKSB7XG4gICAgICBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBjcmVhdGVCZXppZXJNZXNoTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKTtcbiAgICAgIC8vIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgd2hlbiBpdHMgYmFzZSBtYXRlcmlhbCBpcyBkaXNwb3NlZDpcbiAgICAgIGJhc2VNYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZnVuY3Rpb24gb25EaXNwb3NlKCkge1xuICAgICAgICBiYXNlTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcml2ZWRNYXRlcmlhbFxuICB9XG4gIHNldCBtYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gIH1cblxuICAvLyBDcmVhdGUgYW5kIHVwZGF0ZSBtYXRlcmlhbCBmb3Igc2hhZG93cyB1cG9uIHJlcXVlc3Q6XG4gIGdldCBjdXN0b21EZXB0aE1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICB9XG4gIGdldCBjdXN0b21EaXN0YW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICB9XG5cbiAgb25CZWZvcmVSZW5kZXIoKSB7XG4gICAgY29uc3Qge3VuaWZvcm1zfSA9IHRoaXMubWF0ZXJpYWw7XG4gICAgY29uc3Qge3BvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHJhZGl1cywgZGFzaEFycmF5LCBkYXNoT2Zmc2V0fSA9IHRoaXM7XG4gICAgdW5pZm9ybXMucG9pbnRBLnZhbHVlLmNvcHkocG9pbnRBKTtcbiAgICB1bmlmb3Jtcy5jb250cm9sQS52YWx1ZS5jb3B5KGNvbnRyb2xBKTtcbiAgICB1bmlmb3Jtcy5jb250cm9sQi52YWx1ZS5jb3B5KGNvbnRyb2xCKTtcbiAgICB1bmlmb3Jtcy5wb2ludEIudmFsdWUuY29weShwb2ludEIpO1xuICAgIHVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHJhZGl1cztcbiAgICB1bmlmb3Jtcy5kYXNoaW5nLnZhbHVlLnNldChkYXNoQXJyYXkueCwgZGFzaEFycmF5LnksIGRhc2hPZmZzZXQgfHwgMCk7XG4gIH1cblxuICByYXljYXN0KC8qcmF5Y2FzdGVyLCBpbnRlcnNlY3RzKi8pIHtcbiAgICAvLyBUT0RPIC0ganVzdCBmYWlsIGZvciBub3dcbiAgfVxufVxuXG5leHBvcnQgeyBCZXppZXJNZXNoLCBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwsIGV4cGFuZFNoYWRlckluY2x1ZGVzLCBnZXRTaGFkZXJVbmlmb3JtVHlwZXMsIGdldFNoYWRlcnNGb3JNYXRlcmlhbCwgaW52ZXJ0TWF0cml4NCwgdm9pZE1haW5SZWdFeHAgfTtcbiJdLCJuYW1lcyI6WyJTaGFkZXJDaHVuayIsIlVuaWZvcm1zVXRpbHMiLCJNZXNoRGVwdGhNYXRlcmlhbCIsIlJHQkFEZXB0aFBhY2tpbmciLCJNZXNoRGlzdGFuY2VNYXRlcmlhbCIsIlNoYWRlckxpYiIsIk1hdHJpeDQiLCJWZWN0b3IzIiwiTWVzaCIsIkN5bGluZGVyR2VvbWV0cnkiLCJWZWN0b3IyIiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJEb3VibGVTaWRlIiwidm9pZE1haW5SZWdFeHAiLCJleHBhbmRTaGFkZXJJbmNsdWRlcyIsInNvdXJjZSIsInBhdHRlcm4iLCJyZXBsYWNlIiwibWF0Y2giLCJpbmNsdWRlIiwiY2h1bmsiLCJfbHV0IiwiaSIsInRvU3RyaW5nIiwiZ2VuZXJhdGVVVUlEIiwiZDAiLCJNYXRoIiwicmFuZG9tIiwiZDEiLCJkMiIsImQzIiwidXVpZCIsInRvVXBwZXJDYXNlIiwiYXNzaWduIiwiT2JqZWN0IiwidGFyZ2V0IiwiYXJndW1lbnRzIiwibGVuIiwibGVuZ3RoIiwicHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImVwb2NoIiwiRGF0ZSIsIm5vdyIsIkNPTlNUUlVDVE9SX0NBQ0hFIiwiV2Vha01hcCIsIlNIQURFUl9VUEdSQURFX0NBQ0hFIiwiTWFwIiwibWF0ZXJpYWxJbnN0YW5jZUlkIiwiY3JlYXRlRGVyaXZlZE1hdGVyaWFsIiwiYmFzZU1hdGVyaWFsIiwib3B0aW9ucyIsIm9wdGlvbnNLZXkiLCJnZXRLZXlGb3JPcHRpb25zIiwiY3RvcnNCeURlcml2YXRpb24iLCJnZXQiLCJzZXQiLCJjcmVhdGUiLCJwcml2YXRlQmVmb3JlQ29tcGlsZVByb3AiLCJvbkJlZm9yZUNvbXBpbGUiLCJzaGFkZXJJbmZvIiwicmVuZGVyZXIiLCJjYWNoZUtleSIsImN1c3RvbVByb2dyYW1DYWNoZUtleSIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwidXBncmFkZWRTaGFkZXJzIiwidXBncmFkZWQiLCJ1cGdyYWRlU2hhZGVycyIsInVuaWZvcm1zIiwidGltZVVuaWZvcm0iLCJ2YWx1ZSIsIkRlcml2ZWRNYXRlcmlhbCIsImRlcml2ZSIsImNoYWluZWQiLCJjbG9uZSIsImJhc2UiLCJkZXJpdmVkIiwiZGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5IiwiZGVmaW5lcyIsImV4dGVuc2lvbnMiLCJfbGlzdGVuZXJzIiwidW5kZWZpbmVkIiwiY29uc3RydWN0b3IiLCJpc0Rlcml2ZWRNYXRlcmlhbCIsInR5cGUiLCJpc0Rlcml2ZWRGcm9tIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJ0ZXN0TWF0ZXJpYWwiLCJmbiIsImNvcHkiLCJpc1NoYWRlck1hdGVyaWFsIiwibmV3QmFzZSIsImdldERlcHRoTWF0ZXJpYWwiLCJkZXB0aE1hdGVyaWFsIiwiX2RlcHRoTWF0ZXJpYWwiLCJkZXB0aFBhY2tpbmciLCJJU19ERVBUSF9NQVRFUklBTCIsImdldERpc3RhbmNlTWF0ZXJpYWwiLCJkaXN0YW5jZU1hdGVyaWFsIiwiX2Rpc3RhbmNlTWF0ZXJpYWwiLCJJU19ESVNUQU5DRV9NQVRFUklBTCIsImRpc3Bvc2UiLCJtYXRlcmlhbCIsImtleSIsInZlcnRleERlZnMiLCJ2ZXJ0ZXhNYWluSW50cm8iLCJ2ZXJ0ZXhNYWluT3V0cm8iLCJ2ZXJ0ZXhUcmFuc2Zvcm0iLCJmcmFnbWVudERlZnMiLCJmcmFnbWVudE1haW5JbnRybyIsImZyYWdtZW50TWFpbk91dHJvIiwiZnJhZ21lbnRDb2xvclRyYW5zZm9ybSIsImN1c3RvbVJld3JpdGVyIiwicmVzIiwicG9zdENodW5rcyIsInB1c2giLCJqb2luIiwiY29kZSIsIm1hdGNoMSIsImluZGV4IiwiZnVsbFN0ciIsInRlc3QiLCJzdWJzdHIiLCJtYXAiLCJjaGFubmVsIiwiaW5qZWN0SW50b1NoYWRlckNvZGUiLCJzaGFkZXJDb2RlIiwiaWQiLCJkZWZzIiwiaW50cm8iLCJvdXRybyIsIm9wdGlvbnNKc29uUmVwbGFjZXIiLCJfaWRDdHIiLCJvcHRpb25zSGFzaGVzVG9JZHMiLCJvcHRpb25zSGFzaCIsIkpTT04iLCJzdHJpbmdpZnkiLCJNQVRFUklBTF9UWVBFU19UT19TSEFERVJTIiwiTWVzaE5vcm1hbE1hdGVyaWFsIiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJNZXNoTGFtYmVydE1hdGVyaWFsIiwiTWVzaFBob25nTWF0ZXJpYWwiLCJNZXNoVG9vbk1hdGVyaWFsIiwiTWVzaFBoeXNpY2FsTWF0ZXJpYWwiLCJNZXNoTWF0Y2FwTWF0ZXJpYWwiLCJMaW5lQmFzaWNNYXRlcmlhbCIsIkxpbmVEYXNoZWRNYXRlcmlhbCIsIlBvaW50c01hdGVyaWFsIiwiU2hhZG93TWF0ZXJpYWwiLCJTcHJpdGVNYXRlcmlhbCIsImdldFNoYWRlcnNGb3JNYXRlcmlhbCIsImJ1aWx0aW5UeXBlIiwiZ2V0U2hhZGVyVW5pZm9ybVR5cGVzIiwic2hhZGVyIiwidW5pZm9ybVJFIiwiZXhlYyIsImludmVydE1hdHJpeDQiLCJzcmNNYXRyaXgiLCJ0Z3RNYXRyaXgiLCJpbnZlcnQiLCJnZXRJbnZlcnNlIiwiY3JlYXRlQmV6aWVyTWVzaE1hdGVyaWFsIiwicG9pbnRBIiwiY29udHJvbEEiLCJjb250cm9sQiIsInBvaW50QiIsInJhZGl1cyIsImRhc2hpbmciLCJnZW9tZXRyeSIsImRlZmF1bHRCYXNlTWF0ZXJpYWwiLCJjb2xvciIsInNpZGUiLCJCZXppZXJNZXNoIiwiZ2V0R2VvbWV0cnkiLCJ0cmFuc2xhdGUiLCJkYXNoQXJyYXkiLCJkYXNoT2Zmc2V0IiwiZnJ1c3R1bUN1bGxlZCIsImRlcml2ZWRNYXRlcmlhbCIsIl9kZXJpdmVkTWF0ZXJpYWwiLCJfYmFzZU1hdGVyaWFsIiwiX2RlZmF1bHRNYXRlcmlhbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbkRpc3Bvc2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3VzdG9tRGVwdGhNYXRlcmlhbCIsImN1c3RvbURpc3RhbmNlTWF0ZXJpYWwiLCJvbkJlZm9yZVJlbmRlciIsIngiLCJ5IiwicmF5Y2FzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\n");

/***/ })

};
;